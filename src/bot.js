import { TwitterApi } from "twitter-api-v2";
import fetch from "node-fetch";
import dotenv from "dotenv";

dotenv.config();

// Technical Guardrails
export const BOT_DISCLOSURE = "\n\n(Generated by mystyleKPOP AI)";
export const X_HOURLY_LIMIT = 5;
export const X_DAILY_LIMIT = 30;

// Simple in-memory rate limiter
// { [userId]: { hourlyCount, dailyCount, hourlyResetAt, dailyResetAt } }
const xPostCount = {};

/**
 * Checks and increments rate limit for X posting.
 * Returns true if posting is allowed, false if rate limited.
 */
function checkXRateLimit(userId = "default") {
    const now = Date.now();
    if (!xPostCount[userId]) {
        xPostCount[userId] = {
            hourlyCount: 0,
            dailyCount: 0,
            hourlyResetAt: now + 60 * 60 * 1000,
            dailyResetAt: now + 24 * 60 * 60 * 1000,
        };
    }

    const entry = xPostCount[userId];

    // Reset counters if window expired
    if (now >= entry.hourlyResetAt) {
        entry.hourlyCount = 0;
        entry.hourlyResetAt = now + 60 * 60 * 1000;
    }
    if (now >= entry.dailyResetAt) {
        entry.dailyCount = 0;
        entry.dailyResetAt = now + 24 * 60 * 60 * 1000;
    }

    if (entry.hourlyCount >= X_HOURLY_LIMIT) {
        return { allowed: false, reason: `Hourly limit reached (${X_HOURLY_LIMIT}/hour)` };
    }
    if (entry.dailyCount >= X_DAILY_LIMIT) {
        return { allowed: false, reason: `Daily limit reached (${X_DAILY_LIMIT}/day)` };
    }

    entry.hourlyCount++;
    entry.dailyCount++;
    return { allowed: true };
}

/**
 * Validates if a URL is publicly accessible
 */
async function isPubliclyAccessible(url) {
    try {
        const res = await fetch(url, { method: "HEAD" });
        return res.ok;
    } catch (err) {
        return false;
    }
}

/**
 * Rate limit 현황을 조회한다 (카운터를 증가시키지 않음).
 */
export function getRateLimitStatus(userId = "default") {
    const now = Date.now();
    const entry = xPostCount[userId];

    if (!entry) {
        return {
            hourlyCount: 0,
            dailyCount: 0,
            hourlyLimit: X_HOURLY_LIMIT,
            dailyLimit: X_DAILY_LIMIT,
            hourlyResetIn: '60분',
            dailyResetIn: '24시간',
        };
    }

    const hourlyCount = now >= entry.hourlyResetAt ? 0 : entry.hourlyCount;
    const dailyCount = now >= entry.dailyResetAt ? 0 : entry.dailyCount;
    const hourlyResetMs = Math.max(0, entry.hourlyResetAt - now);
    const dailyResetMs = Math.max(0, entry.dailyResetAt - now);

    return {
        hourlyCount,
        dailyCount,
        hourlyLimit: X_HOURLY_LIMIT,
        dailyLimit: X_DAILY_LIMIT,
        hourlyResetIn: `${Math.ceil(hourlyResetMs / 60000)}분`,
        dailyResetIn: `${Math.ceil(dailyResetMs / 60000)}분`,
    };
}

/**
 * Core Bot Logic
 */
export async function postToSNS({ platforms, text, imageUrls }) {
    const safeText = text + BOT_DISCLOSURE;
    const results = {};

    // --- X (Twitter) ---
    if (platforms.includes("x")) {
        const rateCheck = checkXRateLimit();
        if (!rateCheck.allowed) {
            results.x = { success: false, error: rateCheck.reason };
            return results;
        }

        try {
            const client = new TwitterApi({
                appKey: process.env.X_API_KEY,
                appSecret: process.env.X_API_SECRET_KEY,
                accessToken: process.env.X_ACCESS_TOKEN,
                accessSecret: process.env.X_ACCESS_TOKEN_SECRET,
            });

            let mediaIds = [];
            if (imageUrls && Array.isArray(imageUrls)) {
                for (const url of imageUrls.slice(0, 4)) {
                    const response = await fetch(url);
                    const buffer = await response.arrayBuffer();
                    const mediaId = await client.v1.uploadMedia(Buffer.from(buffer), { mimeType: 'image/png' });
                    mediaIds.push(mediaId);
                }
            }

            const tweet = await client.readWrite.v2.tweet({
                text: safeText,
                ...(mediaIds.length > 0 ? { media: { media_ids: mediaIds } } : {}),
            });

            results.x = { success: true, id: tweet.data.id };
        } catch (err) {
            results.x = { success: false, error: err.message };
        }
    }

    // --- Instagram ---
    if (platforms.includes("instagram")) {
        try {
            const igAccountId = process.env.INSTAGRAM_BUSINESS_ACCOUNT_ID;
            const accessToken = process.env.INSTAGRAM_ACCESS_TOKEN;

            const isUrlSafe = await isPubliclyAccessible(imageUrls[0]);
            if (!isUrlSafe) throw new Error("Image URL not publicly accessible");

            const containerRes = await fetch(`https://graph.facebook.com/v19.0/${igAccountId}/media`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                    image_url: imageUrls[0],
                    caption: safeText,
                    access_token: accessToken,
                }),
            });
            const containerData = await containerRes.json();

            const publishRes = await fetch(`https://graph.facebook.com/v19.0/${igAccountId}/media_publish`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ creation_id: containerData.id, access_token: accessToken }),
            });
            const publishData = await publishRes.json();

            results.instagram = { success: true, id: publishData.id };
        } catch (err) {
            results.instagram = { success: false, error: err.message };
        }
    }

    return results;
}

/**
 * 스레드(연결 트윗)를 게시한다.
 * @param {string[]} tweets - 트윗 텍스트 배열 (첫 번째에만 BOT_DISCLOSURE 추가)
 */
export async function postThread(tweets) {
    const rateCheck = checkXRateLimit();
    if (!rateCheck.allowed) {
        return { success: false, error: rateCheck.reason };
    }

    try {
        const client = new TwitterApi({
            appKey: process.env.X_API_KEY,
            appSecret: process.env.X_API_SECRET_KEY,
            accessToken: process.env.X_ACCESS_TOKEN,
            accessSecret: process.env.X_ACCESS_TOKEN_SECRET,
        });

        const results = [];
        let previousTweetId = null;

        for (let i = 0; i < tweets.length; i++) {
            const text = i === 0 ? tweets[i] + BOT_DISCLOSURE : tweets[i];

            const tweetParams = {
                text,
                ...(previousTweetId
                    ? { reply: { in_reply_to_tweet_id: previousTweetId } }
                    : {}),
            };

            const tweet = await client.readWrite.v2.tweet(tweetParams);
            results.push(tweet.data);
            previousTweetId = tweet.data.id;
        }

        return { success: true, tweets: results };
    } catch (err) {
        return { success: false, error: err.message };
    }
}
