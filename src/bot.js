import { TwitterApi } from "twitter-api-v2";
import fetch from "node-fetch";
import dotenv from "dotenv";
import { existsSync } from "fs";
import { db } from "./firebase.js";

if (existsSync('.env.local')) {
    dotenv.config({ path: '.env.local' });
} else {
    dotenv.config();
}

const IMAGE_DOWNLOAD_TIMEOUT_MS = 10000;

/**
 * 이미지 다운로드 (타임아웃 + Content-Type 체크)
 */
async function fetchImageBuffer(url) {
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), IMAGE_DOWNLOAD_TIMEOUT_MS);
    try {
        const response = await fetch(url, { signal: controller.signal });
        if (!response.ok) {
            throw new Error(`Image download failed: HTTP ${response.status}`);
        }
        const contentType = response.headers.get('content-type') || '';
        if (!contentType.startsWith('image/')) {
            throw new Error(`Invalid content-type for image: ${contentType}`);
        }
        const buffer = await response.arrayBuffer();
        return Buffer.from(buffer);
    } finally {
        clearTimeout(timeout);
    }
}

// Technical Guardrails
export const BOT_DISCLOSURE = "\n\n(Generated by mystyleKPOP AI)";
export const X_HOURLY_LIMIT = 5;
export const X_DAILY_LIMIT = 30;

// Simple in-memory rate limiter
// { [userId]: { hourlyCount, dailyCount, hourlyResetAt, dailyResetAt } }
const xPostCount = {};

/**
 * Checks and increments rate limit for X posting.
 * Returns true if posting is allowed, false if rate limited.
 */
function checkXRateLimit(userId = "default") {
    const now = Date.now();
    if (!xPostCount[userId]) {
        xPostCount[userId] = {
            hourlyCount: 0,
            dailyCount: 0,
            hourlyResetAt: now + 60 * 60 * 1000,
            dailyResetAt: now + 24 * 60 * 60 * 1000,
        };
    }

    const entry = xPostCount[userId];

    // Reset counters if window expired
    if (now >= entry.hourlyResetAt) {
        entry.hourlyCount = 0;
        entry.hourlyResetAt = now + 60 * 60 * 1000;
    }
    if (now >= entry.dailyResetAt) {
        entry.dailyCount = 0;
        entry.dailyResetAt = now + 24 * 60 * 60 * 1000;
    }

    if (entry.hourlyCount >= X_HOURLY_LIMIT) {
        return { allowed: false, reason: `Hourly limit reached (${X_HOURLY_LIMIT}/hour)` };
    }
    if (entry.dailyCount >= X_DAILY_LIMIT) {
        return { allowed: false, reason: `Daily limit reached (${X_DAILY_LIMIT}/day)` };
    }

    entry.hourlyCount++;
    entry.dailyCount++;
    return { allowed: true };
}

/**
 * Validates if a URL is publicly accessible
 */
async function isPubliclyAccessible(url) {
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 10000);
    try {
        // HEAD 먼저 시도, 실패하면 GET fallback
        let res = await fetch(url, { method: "HEAD", signal: controller.signal });
        if (!res.ok && res.status === 405) {
            res = await fetch(url, { method: "GET", signal: controller.signal });
        }
        return res.ok;
    } catch (err) {
        return false;
    } finally {
        clearTimeout(timeout);
    }
}

/**
 * Saves post record to Firestore for analytics tracking
 */
async function savePostRecord({ text, platforms, imageUrls, results }) {
    if (!db) return;
    try {
        await db.collection('pending_sns_posts').add({
            text,
            platforms,
            imageUrls: imageUrls || [],
            results,
            status: 'published',
            publishedAt: new Date(),
            engagement_score: 0,
        });
        console.log('[Bot] Post record saved to Firestore for analytics');
    } catch (err) {
        console.error('[Bot] Firestore 저장 실패:', err.message);
    }
}

/**
 * Rate limit 현황을 조회한다 (카운터를 증가시키지 않음).
 */
export function getRateLimitStatus(userId = "default") {
    const now = Date.now();
    const entry = xPostCount[userId];

    if (!entry) {
        return {
            hourlyCount: 0,
            dailyCount: 0,
            hourlyLimit: X_HOURLY_LIMIT,
            dailyLimit: X_DAILY_LIMIT,
            hourlyResetIn: '60분',
            dailyResetIn: '24시간',
        };
    }

    const hourlyCount = now >= entry.hourlyResetAt ? 0 : entry.hourlyCount;
    const dailyCount = now >= entry.dailyResetAt ? 0 : entry.dailyCount;
    const hourlyResetMs = Math.max(0, entry.hourlyResetAt - now);
    const dailyResetMs = Math.max(0, entry.dailyResetAt - now);

    return {
        hourlyCount,
        dailyCount,
        hourlyLimit: X_HOURLY_LIMIT,
        dailyLimit: X_DAILY_LIMIT,
        hourlyResetIn: `${Math.ceil(hourlyResetMs / 60000)}분`,
        dailyResetIn: `${Math.ceil(dailyResetMs / 60000)}분`,
    };
}

/**
 * Core Bot Logic
 */
export async function postToSNS({ platforms, text, imageUrls }) {
    const safeText = text + BOT_DISCLOSURE;
    const results = {};

    // --- X (Twitter) ---
    if (platforms.includes("x")) {
        const rateCheck = checkXRateLimit();
        if (!rateCheck.allowed) {
            results.x = { success: false, error: rateCheck.reason };
            return results;
        }

        try {
            const client = new TwitterApi({
                appKey: process.env.X_API_KEY,
                appSecret: process.env.X_API_SECRET_KEY,
                accessToken: process.env.X_ACCESS_TOKEN,
                accessSecret: process.env.X_ACCESS_TOKEN_SECRET,
            });

            let mediaIds = [];
            if (imageUrls && Array.isArray(imageUrls)) {
                for (const url of imageUrls.slice(0, 4)) {
                    const buffer = await fetchImageBuffer(url);
                    const mediaId = await client.v1.uploadMedia(buffer, { mimeType: 'image/png' });
                    mediaIds.push(mediaId);
                }
            }

            const tweet = await client.readWrite.v2.tweet({
                text: safeText,
                ...(mediaIds.length > 0 ? { media: { media_ids: mediaIds } } : {}),
            });

            results.x = { success: true, id: tweet.data.id };
        } catch (err) {
            results.x = { success: false, error: err.message };
        }
    }

    // --- Instagram ---
    if (platforms.includes("instagram")) {
        try {
            if (!imageUrls || !Array.isArray(imageUrls) || imageUrls.length === 0) {
                throw new Error("Instagram requires at least one image URL");
            }

            const igAccountId = process.env.INSTAGRAM_BUSINESS_ACCOUNT_ID;
            const accessToken = process.env.INSTAGRAM_ACCESS_TOKEN;

            const isUrlSafe = await isPubliclyAccessible(imageUrls[0]);
            if (!isUrlSafe) throw new Error("Image URL not publicly accessible");

            const containerRes = await fetch(`https://graph.facebook.com/v19.0/${igAccountId}/media`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                    image_url: imageUrls[0],
                    caption: safeText,
                    access_token: accessToken,
                }),
            });
            const containerData = await containerRes.json();
            if (containerData.error) {
                throw new Error(`IG container error: ${containerData.error.message}`);
            }

            const publishRes = await fetch(`https://graph.facebook.com/v19.0/${igAccountId}/media_publish`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ creation_id: containerData.id, access_token: accessToken }),
            });
            const publishData = await publishRes.json();
            if (publishData.error) {
                throw new Error(`IG publish error: ${publishData.error.message}`);
            }

            results.instagram = { success: true, id: publishData.id };
        } catch (err) {
            results.instagram = { success: false, error: err.message };
        }
    }

    // Save to Firestore if at least one platform succeeded
    const hasSuccess = (results.x && results.x.success) || (results.instagram && results.instagram.success);
    if (hasSuccess) {
        await savePostRecord({ text, platforms, imageUrls, results });
    }

    return results;
}

/**
 * 스레드(연결 트윗)를 게시한다. 각 트윗에 이미지 첨부 가능.
 * @param {Array<{text: string, imageUrls?: string[]}>} tweets - 트윗 배열
 */
export async function postThread(tweets) {
    // 스레드 내 트윗 수만큼 rate limit 체크 및 카운팅
    for (let i = 0; i < tweets.length; i++) {
        const rateCheck = checkXRateLimit();
        if (!rateCheck.allowed) {
            return { success: false, error: `${rateCheck.reason} (트윗 ${i + 1}/${tweets.length}번째에서 차단)` };
        }
    }

    try {
        const client = new TwitterApi({
            appKey: process.env.X_API_KEY,
            appSecret: process.env.X_API_SECRET_KEY,
            accessToken: process.env.X_ACCESS_TOKEN,
            accessSecret: process.env.X_ACCESS_TOKEN_SECRET,
        });

        const results = [];
        let previousTweetId = null;

        for (let i = 0; i < tweets.length; i++) {
            const item = typeof tweets[i] === 'string' ? { text: tweets[i] } : tweets[i];
            const text = i === 0 ? item.text + BOT_DISCLOSURE : item.text;

            // 이미지 업로드
            let mediaIds = [];
            if (item.imageUrls && Array.isArray(item.imageUrls)) {
                for (const url of item.imageUrls.slice(0, 4)) {
                    const buffer = await fetchImageBuffer(url);
                    const mediaId = await client.v1.uploadMedia(buffer, { mimeType: 'image/png' });
                    mediaIds.push(mediaId);
                }
            }

            const tweetParams = {
                text,
                ...(previousTweetId
                    ? { reply: { in_reply_to_tweet_id: previousTweetId } }
                    : {}),
                ...(mediaIds.length > 0 ? { media: { media_ids: mediaIds } } : {}),
            };

            const tweet = await client.readWrite.v2.tweet(tweetParams);
            results.push(tweet.data);
            previousTweetId = tweet.data.id;
        }

        const successResult = { success: true, tweets: results };

        // Save thread to Firestore
        const threadText = tweets.map(t => typeof t === 'string' ? t : t.text).join('\n---\n');
        await savePostRecord({
            text: threadText,
            platforms: ['x'],
            imageUrls: tweets.flatMap(t => (typeof t !== 'string' && t.imageUrls) ? t.imageUrls : []),
            results: { x: { success: true, id: results[0].id } }
        });

        return successResult;
    } catch (err) {
        return { success: false, error: err.message };
    }
}

/**
 * Instagram 캐러셀(다중 이미지) 게시.
 * Graph API: 각 이미지 → media container → carousel container → publish
 * @param {{ text: string, imageUrls: string[] }} params
 */
export async function postCarousel({ text, imageUrls }) {
    if (!imageUrls || imageUrls.length < 2) {
        return { success: false, error: 'Carousel requires at least 2 images' };
    }

    const safeText = text + BOT_DISCLOSURE;
    const igAccountId = process.env.INSTAGRAM_BUSINESS_ACCOUNT_ID;
    const accessToken = process.env.INSTAGRAM_ACCESS_TOKEN;

    try {
        // 1. 각 이미지 → item container 생성
        const childIds = [];
        for (const url of imageUrls.slice(0, 10)) {
            const isUrlSafe = await isPubliclyAccessible(url);
            if (!isUrlSafe) throw new Error(`Image URL not accessible: ${url}`);

            const res = await fetch(`https://graph.facebook.com/v19.0/${igAccountId}/media`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    image_url: url,
                    is_carousel_item: true,
                    access_token: accessToken,
                }),
            });
            const data = await res.json();
            if (data.error) throw new Error(data.error.message);
            childIds.push(data.id);
        }

        // 2. Carousel container 생성
        const carouselRes = await fetch(`https://graph.facebook.com/v19.0/${igAccountId}/media`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                media_type: 'CAROUSEL',
                children: childIds.join(','),
                caption: safeText,
                access_token: accessToken,
            }),
        });
        const carouselData = await carouselRes.json();
        if (carouselData.error) throw new Error(carouselData.error.message);

        // 3. 게시
        const publishRes = await fetch(`https://graph.facebook.com/v19.0/${igAccountId}/media_publish`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                creation_id: carouselData.id,
                access_token: accessToken,
            }),
        });
        const publishData = await publishRes.json();
        if (publishData.error) throw new Error(publishData.error.message);

        const successResult = { success: true, id: publishData.id };

        // Save carousel to Firestore
        await savePostRecord({
            text,
            platforms: ['instagram'],
            imageUrls,
            results: { instagram: successResult }
        });

        return successResult;
    } catch (err) {
        return { success: false, error: err.message };
    }
}
